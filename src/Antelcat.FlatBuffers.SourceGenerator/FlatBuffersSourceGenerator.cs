using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection.PortableExecutable;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Antelcat.FlatBuffers.SourceGenerator;

[Generator]
public class FlatBuffersSourceGenerator : IIncrementalGenerator
{
    private const string Namespace     = "Antelcat.FlatBuffers";
    private const string AttributeName = "FlatcLocation";

    private const string AttributeSourceCode = $@"// <auto-generated/> Auto generated by Antelcat.FlatBuffers

namespace {Namespace}
{{
    [global::System.AttributeUsage(global::System.AttributeTargets.Assembly)]
    public class {AttributeName} : global::System.Attribute
    {{
        public {AttributeName}(string path){{}}
    }}
}}";

    /// <summary>
    /// /analyzer/dotnet/cs
    /// </summary>
    private static readonly string Current = Path.GetDirectoryName(typeof(FlatBuffersSourceGenerator).Assembly.Location)!;

    /// <summary>
    /// /analyzer/dotnet/tool/{arch}/flatc
    /// </summary>
    private static readonly string Flatc = Path.Combine(Path.GetDirectoryName(Current)!, "tool",
        RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
            ? "win"
            : RuntimeInformation.IsOSPlatform(OSPlatform.Linux)
                ? "linux"
                : RuntimeInformation.IsOSPlatform(OSPlatform.OSX)
                    ? "osx"
                    : throw new InvalidOperationException(), "flatc");

    /// <summary>
    /// /analyzer/dotnet/tool/FileReader.dll
    /// </summary>
    private static readonly string FileReader = Path.Combine(Path.GetDirectoryName(Current)!, "tool", "FileReader.dll");
   
    /// <summary>
    /// /analyzer/dotnet/cs
    /// </summary>
    private static readonly string Temp = Path.GetDirectoryName(typeof(FlatBuffersSourceGenerator).Assembly.Location)!;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(c =>
        {
            c.AddSource($"{Namespace}.{AttributeName}.cs", AttributeSourceCode);
        });
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName($"{Namespace}.{AttributeName}",
            (n, t) => true,
            (n, t) => n);
        context.RegisterSourceOutput(context.AdditionalTextsProvider.Collect().Combine(provider.Collect()),
            (c, s) =>
            {
                var attr = s.Right.SelectMany(x => x.Attributes)
                    .FirstOrDefault(x => x.AttributeClass?.Name == AttributeName);
                if (attr?.ConstructorArguments.FirstOrDefault().Value is not string flatc) flatc = Flatc;
                foreach (var additionalText in s.Left.Where(static x => Path.GetExtension(x.Path) == ".fbs"))
                {
                    if (!Run(additionalText.Path, flatc)) break;
                }

                foreach (var (name, content) in Collect())
                {
                    c.AddSource(name.Replace('/', '.').Replace('\\', '.'),
                        SyntaxFactory.ParseCompilationUnit(content).GetText(Encoding.UTF8));
                }
            });
    }

    private static bool Run(string path, string flatc)
    {
        try
        {
            var process = Process.Start(new ProcessStartInfo
            {
                FileName         = flatc,
                WorkingDirectory = Temp,
                Arguments        = $"-n {path}",
                CreateNoWindow   = true,
            });
            process?.WaitForExit();
        }
        catch (Win32Exception ex)
        {
            return false;
        }

        return true;
    }

    private static IEnumerable<(string name, string content)> Collect()
    {
        Process? process;
        try
        {
            process = Process.Start(new ProcessStartInfo
            {
                FileName               = "dotnet",
                Arguments              = $"{FileReader} {Temp}",
                RedirectStandardOutput = true,
                CreateNoWindow         = true,
            });
        }
        catch (Win32Exception)
        {
            yield break;
        }

        if (process == null) yield break;
        while (!process.HasExited)
        {
            string? output;
            try
            {
                output = process.StandardOutput.ReadLine();
            }
            catch
            {
                yield break;
            }

            if (output is null) yield break;
            if (!output.StartsWith("-n")) continue;
            var          name    = output.Substring(2);
            List<string> content = [];
            do
            {
                var line = process.StandardOutput.ReadLine();
                if (line is null || line.StartsWith("-f") || !line.StartsWith("-c")) break;
                content.Add(line.Substring(2));
            } while (true);

            yield return (name, string.Join("\n", content));
        }

    }
}
